(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{230:function(e,t,r){"use strict";r.r(t);var n=r(0),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"vision"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vision"}},[e._v("#")]),e._v(" Vision")]),e._v(" "),r("h2",{attrs:{id:"recent-list"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#recent-list"}},[e._v("#")]),e._v(" recent list")]),e._v(" "),r("blockquote",[r("p",[e._v("https://thebookofshaders.com/")])]),e._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://ai.googleblog.com/2019/04/evaluating-unsupervised-learning-of.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("disentanglement"),r("OutboundLink")],1)])]),e._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://export.arxiv.org/pdf/1904.05049",target:"_blank",rel:"noopener noreferrer"}},[e._v("octave convolution"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("separate high and low freq convolution, compress low frequency to reduce memory and flop, update and exchange between high and low, during training")]),e._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://arxiv.org/pdf/1807.03247.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("coord convolution"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("add a coordinate layer to help convolution locate")]),e._v(" "),r("h2",{attrs:{id:"tools"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tools"}},[e._v("#")]),e._v(" tools")]),e._v(" "),r("p",[e._v("sketchfeb")]),e._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://github.com/google-research/disentanglement_lib",target:"_blank",rel:"noopener noreferrer"}},[e._v("disentanglement lib"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"datasets"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#datasets"}},[e._v("#")]),e._v(" datasets")]),e._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://github.com/google-research/disentanglement_lib",target:"_blank",rel:"noopener noreferrer"}},[e._v("disentanglement lib"),r("OutboundLink")],1)])]),e._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://github.com/deepmind/3d-shapes",target:"_blank",rel:"noopener noreferrer"}},[e._v("3d shapes"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"tutorials"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tutorials"}},[e._v("#")]),e._v(" tutorials")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/lettier/3d-game-shaders-for-beginners",target:"_blank",rel:"noopener noreferrer"}},[e._v("shader intro"),r("OutboundLink")],1)]),e._v(" "),r("h2",{attrs:{id:"geometric-mesh"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#geometric-mesh"}},[e._v("#")]),e._v(" geometric mesh")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("https://github.com/danielepanozzo/gp")])]),e._v(" "),r("li",[r("p",[r("a",{attrs:{href:"http://igl.ethz.ch/projects/bbw/bounded-biharmonic-weights-siggraph-2011-slides-compressed-jacobson-et-al.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Bounded Biharmonic Weights for Real-Time Deformation"),r("OutboundLink")],1)])])]),e._v(" "),r("p",[e._v("simultaneous localization and mapping (SLAM)")]),e._v(" "),r("blockquote",[r("p",[e._v("reconstruction fusion")])]),e._v(" "),r("ul",[r("li",[r("p",[e._v("DynamicFusion [2],\nhigh occlusion from the single view\nreal-time performance\ngeometry/skeleton prior knowledge")])]),e._v(" "),r("li",[r("p",[e._v("Volume Deform [3],")])]),e._v(" "),r("li",[r("p",[e._v("Double Fusion4D\nreconstruct both the inner body and outer surface\nadding body template")])]),e._v(" "),r("li",[r("p",[e._v("Albedo based fusion")])]),e._v(" "),r("li",[r("p",[e._v("killing fusion / sobelev fusion\ntopology changes and fast inter-frame motions")])]),e._v(" "),r("li",[r("p",[e._v("articulated fusion")]),e._v(" "),r("ul",[r("li",[e._v("segmentation constrains all nodes labeled to the same segment having transformation as close as possible - reduce solution space")]),e._v(" "),r("li",[e._v("self-adapted segmentation")]),e._v(" "),r("li",[e._v("registration, segmentation, and fusion")]),e._v(" "),r("li",[e._v("clustering of a set of deformed nodes based on their motion trajectories by merging and swapping")])])])]),e._v(" "),r("p",[e._v("https://github.com/andyzeng/tsdf-fusion-pythons")]),e._v(" "),r("h2",{attrs:{id:"project"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#project"}},[e._v("#")]),e._v(" project")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("atamid, rig animation using Tangible and Modular Input Device")])]),e._v(" "),r("li",[r("p",[e._v("mesh optimizer")])])]),e._v(" "),r("h2",{attrs:{id:"gl"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gl"}},[e._v("#")]),e._v(" GL")]),e._v(" "),r("p",[r("strong",[e._v("vbo")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("GLuint vbo;\nglGenBuffers(1, &vbo); // Generate 1 buffer\n\nglBindBuffer(GL_ARRAY_BUFFER, vbo);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n")])])]),r("p",[r("strong",[e._v("shader")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('const char* vertexSource = R"glsl(\n    #version 150 core\n\n    in vec2 position;\n\n    void main()\n    {\n        gl_Position = vec4(position, 0.0, 1.0);\n    }\n)glsl";\n\nGLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);\nglShaderSource(vertexShader, 1, &vertexSource, NULL);\nglCompileShader(vertexShader);\n\n// check shader\nGLint status;\nglGetShaderiv(vertexShader, GL_COMPILE_STATUS, &status); // return GL_TRUE\n// compile log\nchar buffer[512];\nglGetShaderInfoLog(vertexShader, 512, NULL, buffer);\n\nGLuint shaderProgram = glCreateProgram();\nglAttachShader(shaderProgram, vertexShader);\nglAttachShader(shaderProgram, fragmentShader);\n\nglDrawBuffer\nglDeleteShader\nglDetachShader\n')])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('GLint posAttrib = glGetAttribLocation(shaderProgram, "position");\nglVertexAttribPointer(posAttrib, 2, GL_FLOAT, GL_FALSE, 0, 0);\nglEnableVertexAttribArray(posAttrib);\n')])])]),r("p",[r("strong",[e._v("vao")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("GLuint vao;\nglGenVertexArrays(1, &vao);\nglBindVertexArray(vao);\n\nglDrawArrays(GL_TRIANGLES, 0, 3);\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('GLint uniColor = glGetUniformLocation(shaderProgram, "triangleColor");\nglUniform3f(uniColor, 1.0f, 0.0f, 0.0f);\nauto t_start = std::chrono::high_resolution_clock::now();\n\n...\n\nauto t_now = std::chrono::high_resolution_clock::now();\nfloat time = std::chrono::duration_cast<std::chrono::duration<float>>(t_now - t_start).count();\n\nglUniform3f(uniColor, (sin(time * 4.0f) + 1.0f) / 2.0f, 0.0f, 0.0f);\n')])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('GLint posAttrib = glGetAttribLocation(shaderProgram, "position");\nglEnableVertexAttribArray(posAttrib);\nglVertexAttribPointer(posAttrib, 2, GL_FLOAT, GL_FALSE,\n                       5*sizeof(float), 0);\n\nGLint colAttrib = glGetAttribLocation(shaderProgram, "color");\nglEnableVertexAttribArray(colAttrib);\nglVertexAttribPointer(colAttrib, 3, GL_FLOAT, GL_FALSE,\n                       5*sizeof(float), (void*)(2*sizeof(float)));\n')])])]),r("p",[r("strong",[e._v("ebo")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("GLuint elements[] = {\n    0, 1, 2\n};\n\nGLuint ebo;\nglGenBuffers(1, &ebo);\n\n...\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER,\n    sizeof(elements), elements, GL_STATIC_DRAW);\n\nglDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_INT, 0);\n")])])]),r("p",[r("strong",[e._v("framebuffer")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("GLuint frameBuffer;\nglGenFramebuffers(1, &frameBuffer);\n\nglCheckFramebufferStatus\nGL_FRAMEBUFFER_COMPLETE\n\nglBindFramebuffer(GL_FRAMEBUFFER, frameBuffer);\n\nglDeleteFramebuffers(1, &frameBuffer);\n")])])]),r("p",[r("strong",[e._v("texture")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("GLuint texColorBuffer;\nglGenTextures(1, &texColorBuffer);\nglBindTexture(GL_TEXTURE_2D, texColorBuffer);\n\nglTexImage2D(\n    GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL\n);\n\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\nglFramebufferTexture2D(\n    GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, 0\n);\n")])])]),r("p",[e._v("GL_STATIC_DRAW: The vertex data will be uploaded once and drawn many times (e.g. the world).\nGL_DYNAMIC_DRAW: The vertex data will be created once, changed from time to time, but drawn many times more than that.\nGL_STREAM_DRAW: The vertex data will be uploaded once and drawn once.")]),e._v(" "),r("blockquote",[r("p",[e._v("https://glm.g-truc.net/0.9.9/index.html")])]),e._v(" "),r("blockquote",[r("p",[e._v("https://en.wikipedia.org/wiki/Advanced_Vector_Extensions")])]),e._v(" "),r("blockquote",[r("p",[e._v("https://www.cgal.org/\nhttps://www.cgal.org/project.html#")])])])}),[],!1,null,null,null);t.default=a.exports}}]);